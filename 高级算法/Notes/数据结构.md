# Treap

Treap是一种平衡二叉搜索树，它把二叉搜索树和堆的特性融合在一起，所以它被命名为Treap（Tree+Heap）。

Treap的主要思想是对于每一个节点，它都有一个键值(key)和一个优先级(priority)。在整个树中，按照键值的大小满足二叉搜索树的性质（左子树的键值小于根节点，右子树的键值大于根节点）；按照优先级的大小满足堆的性质（每个节点的优先级都不大于它的父节点的优先级）。这样，Treap就融合了二叉搜索树查找的高效性和堆调整的高效性。

Treap的主要步骤：
1. **插入操作**：
    - 首先，把新节点插入到二叉搜索树中，即新节点的键值需要满足二叉搜索树的性质。由于新节点的插入，二叉搜索树可能会失去平衡。
    - 其次，根据新节点的优先级进行调整。如果新节点的优先级大于父节点的优先级，就进行旋转操作（右旋或左旋）。
    - 最后，不断旋转，直到新节点的优先级不大于其父节点的优先级，或者它成为了根节点。

2. **删除操作**：
    - 首先，找到需要删除的节点。
    - 其次，无论删除节点的左右子树是否存在，我们都把它当做是存在的，然后比较左右子树根节点的优先级，把优先级大的子树进行旋转操作（右旋或左旋），使删除节点下沉。
    - 最后，当删除节点成为叶子节点时，直接删除它。

3. **查找操作**：
    - 由于Treap是一种二叉搜索树，所以查找操作和二叉搜索树的查找操作一样，从根节点开始，如果查找的键值小于当前节点的键值，就在左子树查找，如果大于当前节点的键值，就在右子树查找，直到找到要查找的节点。

```cpp
#include <bits/stdc++.h>
using namespace std;

struct Node {
    int key, priority;
    Node *left, *right;

    Node(int key, int priority) {
        this->key = key;
        this->priority = priority;
        this->left = this->right = nullptr;
    }
};

// 左旋
Node* rotateLeft(Node* root) {
    Node* newRoot = root->right;
    root->right = newRoot->left;
    newRoot->left = root;
    return newRoot;  // 新的根节点
}

// 右旋
Node* rotateRight(Node* root) {
    Node* newRoot = root->left;
    root->left = newRoot->right;
    newRoot->right = root;
    return newRoot;  // 新的根节点
}

// 插入操作
Node* insert(Node* root, int key, int priority) {
    // 如果根节点为空，返回一个新节点
    if (root == nullptr) return new Node(key, priority);

    // 如果插入的键值小于根节点的键值
    if (key < root->key) {
        // 插入到左子树
        root->left = insert(root->left, key, priority);
        // 如果左子树的优先级大于根节点的优先级，进行右旋
        if (root->left->priority > root->priority) {
            root = rotateRight(root);
        }
    }
    // 如果插入的键值大于等于根节点的键值
    else {
        // 插入到右子树
        root->right = insert(root->right, key, priority);
        // 如果右子树的优先级大于根节点的优先级，进行左旋
        if (root->right->priority > root->priority) {
            root = rotateLeft(root);
        }
    }
    return root;
}

// 删除操作
Node* deleteNode(Node* root, int key) {
    // 如果根节点为空，直接返回
    if (root == nullptr) return root;
    // 如果删除的键值小于根节点的键值
    if (key < root->key) {
        root->left = deleteNode(root->left, key);
    }
    // 如果删除的键值大于根节点的键值
    else if (key > root->key) {
        root->right = deleteNode(root->right, key);
    }
    // 如果删除的键值等于根节点的键值
    else {
        // 如果根节点是叶子节点，直接删除
        if (root->left == nullptr && root->right == nullptr) {
            delete root;
            root = nullptr;
        }
        // 如果根节点的左子树为空，把右子树设为新的根节点
        else if (root->left == nullptr) {
            Node* temp = root;
            root = root->right;
            delete temp;
        }
        // 如果根节点的右子树为空，把左子树设为新的根节点
        else if (root->right == nullptr) {


            Node* temp = root;
            root = root->left;
            delete temp;
        }
        // 如果根节点的左右子树都不为空
        else {
            // 如果左子树的优先级大于右子树的优先级，进行右旋
            if (root->left->priority > root->right->priority) {
                root = rotateRight(root);
                root->right = deleteNode(root->right, key);
            }
            // 如果左子树的优先级小于等于右子树的优先级，进行左旋
            else {
                root = rotateLeft(root);
                root->left = deleteNode(root->left, key);
            }
        }
    }
    return root;
}

// 查找操作
bool search(Node* root, int key) {
    while (root != nullptr) {
        // 如果查找的键值等于根节点的键值
        if (key == root->key) return true;
        // 如果查找的键值小于根节点的键值
        if (key < root->key) root = root->left;
        // 如果查找的键值大于根节点的键值
        else root = root->right;
    }
    return false;
}
```
以上代码没有对重复键值做处理。如果需要处理重复键值，可以根据具体需求对代码进行适当的修改。

# 跳表

跳表是一种动态数据结构，它维护了一个有序序列，并提供了插入，删除，查找等操作，同时保证了对数级别的时间复杂度，它的效率可以与平衡树和二分查找树相媲美。

跳表通过构造多级索引来提高查询的效率，高级别的索引的节点数少于下级别的。一个跳表中节点包含了key、value和一个指向同一列表中其他节点的指针数组。key和value表示节点存储的数据，而指针数组则用于维护节点之间的顺序关系和层级关系。

跳表的主要步骤：

**插入操作**：新的节点按照规定的位置插入到最底层链表中，并随机的确定该节点的高度（需要出现在哪些层的链表中），然后将该节点插入到对应的链表中去。

**删除操作**：查找到每一层中待删除节点，修改它们的前后节点的指针，然后删除这些节点。

**查找操作**：从最顶层的链表开始查找，找到最后一个键值小于要查找的键值的节点，然后转到该节点的下一层继续查找，直到找到要查找的节点。

```cpp
#include <iostream>
#include <cstdlib>
#include <cmath>
#include <vector>
#include <limits>
using namespace std;

// 定义跳表节点结构
struct Node {
    int key;
    vector<Node*> forward;
    Node (int k, int level) : key(k), forward(level, nullptr) {}
};

// 跳表
class SkipList {
public:
    SkipList() : level(0), size(0) {
        int maxLevel = static_cast<int>(log(numeric_limits<int>::max()) / log(2));
        header = new Node(0, maxLevel);
    }

    // 查找
    bool search(int searchKey) {
        Node* x = header;
        for (int i = level; i >= 0; i--) {
            while (x->forward[i] != nullptr && x->forward[i]->key < searchKey) {
                x = x->forward[i];
            }
        }
        x = x->forward[0];
        return x != nullptr && x->key == searchKey;
    }

    // 插入
    void insert(int searchKey) {
        vector<Node*> update(header->forward);
        Node* x = header;
        for (int i = level; i >= 0; i--) {
            while (x->forward[i] != nullptr && x->forward[i]->key < searchKey) {
                x = x->forward[i];
            }
            update[i] = x;
        }
        x = x->forward[0];
        if (x == nullptr || x->key != searchKey) {
            int newLevel = randomLevel();
            if (newLevel > level) {
                for (int i = level + 1; i < newLevel + 1; i++) {
                    update[i] = header;
                }
                level = newLevel;
            }
            x = new Node(searchKey, newLevel + 1);
            for (int i = 0; i <= newLevel; i++) {
                x->forward[i] = update[i]->forward[i];
                update[i]->forward[i] = x;
            }
            size++;
        }
    }

    // 删除
    void erase(int searchKey) {
        vector<Node*> update(header->forward);
        Node* x = header;
        for (int i = level; i >= 0; i--) {
            while (x->forward[i] != nullptr && x->forward[i]->key < searchKey) {
                x = x->forward[i];
            }
            update[i] = x;
        }
        x = x->forward[0];
        if (x->key == searchKey) {
            for (int i = 0; i <= level; i++) {
                if (update[i]->forward[i] != x) {
                    break;
                }
                update[i]->forward[i] = x->forward[i];
            }
            delete x;
            while (level > 0 && header->forward[level] == nullptr) {
                level--;
            }
            size--;
        }
    }

private:
    // 随机生成层数
    int randomLevel() {
        int newLevel = 0;
        while (rand() < RAND_MAX / 2 && newLevel < header->forward.size() - 1) {
            newLevel++;
        }
        return newLevel;
    }

    Node* header;
    int level;
    int size;
};

int main() {
    SkipList sl;
    sl.insert(3);
    sl.insert(6);
    sl.insert(9);
    sl.insert(12);
    sl.insert(19);
    sl.insert(17);

    cout << sl.search(19) << endl;
    sl.erase(19);
    cout << sl.search(19) << endl;

    return 0;
}
```

# 哈希表

**第一部分：2-universal哈希算法的定义与扩展**

2-Universal Hashing是一个强大的工具，用于设计数据结构，它可以抵抗敌手选择输入来构造最坏情况的可能性。严格来说，它是一种设计哈希函数的方法。

**定义：** 

假设我们有一系列哈希函数 $H=\{h:U \rightarrow [0, m-1]\}$，其中 $U$ 是所有可能输入的集合，$m$ 是哈希表的大小。如果对于所有不同的输入 $x$ 和 $y$，我们从 $H$ 中随机选取的哈希函数 $h$ 有 $\Pr[h(x) = h(y)] \leq 1/m$，那么我们称 $H$ 是 2-universal 的。

换句话说，任意两个不同的输入被哈希到同一个位置的概率不会超过 $1/m$。 这是一个非常强大的属性，因为即使一个敌手知道我们使用的是 2-Universal hashing，他仍然无法选择输入来引发哈希冲突。

**扩展：**

2-Universal Hashing 的一个扩展是 k-Universal Hashing。如果哈希函数集 $H$ 满足对于任意 $k$ 个不同的输入 $x_1, x_2, \dots, x_k$，每个可能的 $k$ 元组在哈希表中的位置的概率分布与从 $[0, m-1]^k$ 中随机选择的 $k$ 元组的概率分布一致，那么我们称 $H$ 是 k-Universal 的。这意味着我们无法找到一个 $k$ 元组，它被哈希到特定位置的概率比任何其他 $k$ 元组的概率更高。

2-Universal Hashing 和 k-Universal Hashing 都可以用于设计防止敌手制造最坏情况的数据结构，但 k-Universal Hashing 可以提供更强大的保护。然而，实现 k-Universal Hashing 通常比实现 2-Universal Hashing 更复杂，所以在实践中，人们通常只使用 2-Universal Hashing。
