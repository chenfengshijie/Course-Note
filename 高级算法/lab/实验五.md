# 随机算法课程实验报告

# 实验一：用minHash实现集合的相似性连接

| 姓名 | 陈峰       |
| ---- | ---------- |
| 学号 | 7203610323 |
| 班级 | 20WJ0313   |


| 评分表：   | （由老师填写） |
| ---------- | -------------- |
| 最终得分： |
对实验题目的理解是否透彻：     
实验步骤是否完整、可信  ：        
代码质量                ：
实验报告是否规范        ：
趣味性、难度加分        ：       
特色1：
特色2：
特色3：

---

# 一、实验题目概述

阅读《random sample over join revisit》， Sigmod 2018论文，并对论文中的算法进行实现。

# 二、对实验步骤的详细阐述

本文的算法主要针对了三个不同的连接方式：Chain Join、Acycle Join和Star Join。由于时间和能力所限，本文只实现了Chain Join的算法。
Chain Join算法也主要分为了三个部分：

- Olken Weight.该算法直接使用了元组中的频率最高的值作为元组的权重，该算法实现简单，并且不需要很长时间的初始化，但是该算法的拒绝率很高，采样的效果不好。
- Exact Weight.该算法使用动态规划来求解每一个元组的权重，该算法的拒绝率很低，但是该算法的初始化时间很长。
- Random Walk。该算法先通过随机游走来进行采样，然后再通过动态规划来求解采样次数较少的元组，该算法的拒绝率和初始化时间都在前两者之间。

在该实验中，我将Olken Weight和Exact Weight实现在了同一个类中，因为它们只有在初始化元组权重的时候不同，其他的采样和数据表示都一致。

对于Random Walk算法，我将其实现在了另一个类中，我继承了上述的类，然后重写了其中的采样函数，并添加了随机游走的函数，并且实现了自顶向下的动态规划算法，用于在采样的时候采样到游走次数较少的元组。

#  三、实验数据

## 1. 实验设置

### 实验环境

Window 10 64位,vscode ,vs2022

### 实验数据

在采用了一个数据集，即Popular_frequency.txt,popular_user_table.txt,twitter_combine,twitter_frequency这四个给定的Table参与连接。

## 2. 实验结果

| time\algorithm | olken_weight | exact_weight | random_walk                   |
| -------------- | ------------ | ------------ | ----------------------------- |
| init_time      | <1s          | >10min       | 5~10min                       |
| sample_time    | >30s         | <1s          | <1s(slow when begin sampling) |


# 四、对实验结果的理解和分析

1. 初始化时间的解释。这个主要和采用的算法相关，olken weight只需要统计每组数据的最大值即可，而Exact Weight需要对每个元组进行动态规划，所以初始化时间会很长，而Random Walk初始化时间和随机游走次数相关，并且在随机游走结束之后对于个别元组进行动态规划时采用的置信度有关（游走多少次才能认为有效，而不再采用动态规划）
2. 采样的时间分析。由于Exact Weight算法的初始化时间很长，所以在采样的时候，Exact Weight算法的采样时间很短，而Random Walk算法的采样时间和随机游走的次数有关，所以在采样的时候，Random Walk算法的采样时间很短，而Olken Weight算法的采样时间很长，因为它的拒绝率很高，所以需要采样很多次才能得到足够的样本。random_walk方法在初始的时候会慢一些主要因为在最初的时候会对某些元组进行一些自顶向下的动态规划。

# 五、实验过程中最值得说起的几个方面

- 本文使用c++完成所有步骤,对于是数据的连接操作，没有使用数据库，而是使用了c++的map来进行数据的连接操作，这也限制了本次实验的数据规模大小。
- 实现了三个算法olken、exact、random_walk。