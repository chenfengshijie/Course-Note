# 词法分析
这部分使用正则语言来进行词法的识别。
正则语言（Regular Language）是一类简单的形式语言，可以由正则表达式描述或由有限自动机（Finite Automaton）识别。正则语言具有良好的数学性质，因此在计算机科学、自然语言处理、编译器设计等领域有着广泛的应用。

1. 正则表达式（Regular Expression）：
正则表达式是一种用于描述正则语言的紧凑符号表示。它们通常包括以下基本操作和符号：

- 字母表（Alphabet）：正则语言的基本符号，例如 {a, b}。
- 空串（Epsilon）：表示不包含任何符号的字符串，用ε表示。
- 并（Union）：表示语言中的两个子集的并集，例如A | B，表示A和B中的字符串。
- 连接（Concatenation）：表示两个字符串的连接，例如 AB，表示字符串A和字符串B的连接。
- 克林闭包（Kleene Closure）：表示一个字符串的任意次重复，例如A*，表示字符串A的0次或多次重复。
2. 有限自动机（Finite Automaton）：
有限自动机是一种能够识别正则语言的计算模型。它包括以下组成部分：

- 状态集（States）：有限自动机中的一组状态，用 Q 表示。
- 输入字母表（Input Alphabet）：有限自动机接受的输入符号集合，用 Σ 表示。
- 转移函数（Transition Function）：描述有限自动机如何根据输入符号从一个状态转移到另一个状态的函数， 用 δ 表示。
- 初始状态（Initial State）：有限自动机的起始状态，用 q0 表示。
- 接受状态集（Accepting States）：当有限自动机停在这些状态时，表示输入字符串被接受，用 F 表示。
有限自动机分为两类：确定性有限自动机（DFA，Deterministic Finite Automaton）和非确定性有限自动机（NFA，Nondeterministic Finite Automaton）。它们之间的主要区别在于转移函数。在DFA中，每个状态在读取一个输入符号时只有一个确定的转移状态；而在NFA中，一个状态在读取一个输入符号时可能有多个或没有转移状态。

下面列举了正则表达式中常见的符号、操作符及其含义：

1. 基本符号：
- a, b, c...：字母表中的单个字符，表示匹配该字符本身。
- . ：点号，表示匹配任意单个字符（除换行符之外）。
2. 数量词：
- ：表示前面的字符或表达式可以重复0次或多次。例如，a 表示匹配0个或多个连续的'a'字符。
- +：表示前面的字符或表达式可以重复1次或多次。例如，a+ 表示匹配1个或多个连续的'a'字符。
- ?：表示前面的字符或表达式可以重复0次或1次。例如，a? 表示匹配0个或1个'a'字符。
- {m}：表示前面的字符或表达式必须重复m次。例如，a{3} 表示匹配恰好3个连续的'a'字符。
- {m,}：表示前面的字符或表达式至少重复m次。例如，a{3,} 表示匹配至少3个连续的'a'字符。
- {m,n}：表示前面的字符或表达式可以重复m次到n次。例如，a{3,5} 表示匹配3个到5个连续的'a'字符。
3. 字符类：
- [abc]：表示匹配方括号内的任意一个字符。例如，[abc] 表示匹配'a'、'b'或'c'中的任意一个字符。
- [^abc]：表示匹配除方括号内字符之外的任意一个字符。例如，[^abc] 表示匹配除'a'、'b'和'c'之外的任意一个字符。
- [a-z]：表示匹配指定范围内的任意一个字符。例如，[a-z] 表示匹配小写英文字母中的任意一个字符。
- [^a-z]：表示匹配指定范围之外的任意一个字符。例如，[^a-z] 表示匹配除小写英文字母之外的任意一个字符。
4. 分组和选择：
- (A|B)：表示匹配A或B中的任意一个表达式。例如，(ab|cd) 表示匹配字符串'ab'或'cd'。
- (A)：表示将A作为一个整体进行匹配。例如，(ab)+ 表示匹配1个或多个连续的'ab'字符串，如"ab"、"abab"、"ababab"等。
5. 预定义字符类：
- \d：表示匹配任意一位数字字符，等同于[0-9]。
- \D：表示匹配任意\s：表示匹配任意一个空白字符（包括空格、制表符、换行符等），等同于[\t\n\r\f\v]。
- \S：表示匹配任意一个非空白字符，等同于[^\t\n\r\f\v]。
- \w：表示匹配任意一个字母、数字或下划线字符，等同于[a-zA-Z0-9_]。
- \W：表示匹配任意一个非字母、非数字和非下划线字符，等同于[^a-zA-Z0-9_]。
6. 边界：
- ^：表示匹配字符串的开始位置。例如，^a 表示匹配以'a'开头的字符串。
- $：表示匹配字符串的结束位置。例如，a$ 表示匹配以'a'结尾的字符串。
- \b：表示匹配单词边界。例如，\bword\b 表示匹配独立的单词'word'。
- \B：表示匹配非单词边界。
7. 贪婪与非贪婪匹配：
- 在默认情况下，正则表达式的数量词是贪婪的，即会尽可能多地匹配字符。但在某些情况下，我们需要进行非贪- 婪匹配，即尽可能少地匹配字符。可以通过在数量词后面添加一个问号来实现非贪婪匹配。
- *?：表示前面的字符或表达式可以重复0次或多次的非贪婪匹配。
- +?：表示前面的字符或表达式可以重复1次或多次的非贪婪匹配。
- ??：表示前面的字符或表达式可以重复0次或1次的非贪婪匹配。
- {m,n}?：表示前面的字符或表达式可以重复m次到n次的非贪婪匹配。


# 语法分析

## LL(1)文法
LL(1)文法是一类特殊的上下文无关文法（Context-Free Grammar，CFG），它适用于自顶向下的预测性语法分析方法，如递归下降分析和预测分析。LL(1)文法具有良好的性质，易于实现，因此在编译器设计和自然语言处理等领域具有一定的应用。

LL(1)文法的定义中，"LL"表示从左到右（Left-to-right）扫描输入并构建最左推导（Leftmost derivation），"1"表示在分析过程中仅查看输入符号的下一个（1个）字符。换句话说，LL(1)文法在分析输入时，只需要查看当前输入符号的下一个字符即可决定应用哪个产生式。

一个上下文无关文法G（由非终结符集合N、终结符集合T、产生式集合P和开始符号S组成）是LL(1)文法，当且仅当满足以下条件：

1. 对于文法中的任意两个不同的产生式 A -> α 和 A -> β，它们的选择集（Select Set）不相交。选择集是一个终结符集合，用于确定在分析过程中应用哪个产生式。
2. 如果文法中存在产生式 A -> ε，则它的选择集不能与任何其他以 A 为左侧的产生式的选择集相交。
   
为了确定一个文法是否是LL(1)文法，我们需要计算FIRST集和FOLLOW集：

1. FIRST集：对于文法中的每个符号X（可以是非终结符或终结符），FIRST(X)是一个终结符集合，表示在X的任意派生中可能出现的第一个终结符。如果X可以导出空串ε，则将ε也包含在FIRST(X)中。
2. FOLLOW集：对于文法中的每个非终结符A，FOLLOW(A)是一个终结符集合，表示在A的任意派生中可能紧跟在A后面的终结符。如果A可以出现在句子的末尾，则将特殊结束标记$也包含在FOLLOW(A)中。
3. 
当我们得到FIRST集和FOLLOW集后，可以计算产生式的选择集。对于文法中的产生式 A -> α：

1. 如果α可以导出空串ε，那么选择集为：SELECT(A -> α) = FIRST(α) ∪ FOLLOW(A)。
2. 如果α不能导出空串ε，那么选择集为：SELECT(A -> α) = FIRST(α)。
在计算了产生式的选择集后，我们可以检查文法是否满足LL(1)文法的条件。如果满足，我们可以使用递归下降分析或预测分析表来构建一个自顶向下的语法分析

## LR文法
LR文法（Left-to-right, Rightmost derivation in reverse）是一类上下文无关文法，它适用于自底向上的分析方法。LR文法通过从左到右扫描输入并构建最右推导的逆序（即从句子到开始符号的推导过程）来解析输入。相较于LL文法，LR文法能够描述更广泛的语言集合，并且具有更好的错误检测和恢复能力。LR分析器是编译器中常用的语法分析器类型。

LR文法的命名约定与LL文法类似。在LR(k)文法中，"L"表示从左到右扫描输入，"R"表示构建最右推导的逆序，"k"表示在分析过程中需要查看输入符号的下k个字符。在实际应用中，LR(1)文法是最常见的，因为LR(1)文法在处理能力和实现复杂性之间达到了较好的平衡。

为了构建LR分析器，我们需要生成一个状态机（通常是一个DFA，确定性有限自动机），其状态表示自底向上分析过程中可能遇到的部分句型。状态机的转移则基于产生式的部分推导。在分析过程中，分析器将输入符号压入一个栈，根据当前状态和下一个输入符号来决定采取移进（Shift）操作还是归约（Reduce）操作。移进操作将输入符号压入栈中并转移到下一个状态；归约操作根据栈中的部分句型应用相应的产生式进行逆推导，并弹出栈中相应的符号。

根据状态机的构建方法和使用的信息，LR分析器可以分为以下几种类型：

- SLR（Simple LR）分析器：SLR分析器使用简化的方法构建状态机，只考虑文法中的项集（Item Set）。SLR分析器构建的状态机可能比较简单，但处理能力有限，不能处理某些具有二义性或左递归的文法。

- Canonical LR分析器：Canonical LR分析器使用更精确的方法构建状态机，考虑文法中的项集和向前看符号（Lookahead Symbol）。Canonical LR分析器具有很强的处理能力，可以处理更复杂的文法，但构建过程可能产生大量的状态，导致实现复杂。

- LALR（Look-Ahead LR）分析器：LALR分析器是Canonical LR分析器的一种优化，通过合并具有相同核心项集（Core Item Set）的状态来减少状态机的大小。LALR分析器在处理能力和实现复杂性之间取得了较好的平衡，因此在实际应用中广泛应用。

在实际编译器中，通常使用诸如YACC（Yet Another Compiler-Compiler）、Bison等工具来自动生成LALR分析器，以降低开发成本和复杂性。

下面是构建LR分析器的一般步骤：
1. 增广文法：给定文法G，为其添加一个新的产生式S' -> S，其中S'是一个新的开始符号，S是原始文法的开始符号。

2. 构建项目集族（Item Set Family）：项目集是文法产生式的扩展，表示部分推导的过程。项目集族是项目集的集合，它反映了自底向上分析过程中可能出现的部分句型。

3. 构建DFA：根据项目集族，构建一个DFA，状态表示项目集，转移基于产生式的部分推导。对于Canonical LR分析器和LALR分析器，还需要考虑向前看符号。

4. 构建分析表：根据DFA构建分析表。分析表包括ACTION表和GOTO表。ACTION表用于确定移进（Shift）和归约（Reduce）操作；GOTO表用于在归约操作后确定转移到的状态。

5. 自底向上分析：使用分析表和栈来对输入进行自底向上分析。分析器根据当前状态和下一个输入符号来查找分析表，确定执行移进操作还是归约操作。

总之，LR文法是一类上下文无关文法，适用于自底向上分析方法。LR分析器能够处理更广泛的语言集合，并具有较好的错误检测和恢复能力。根据状态机的构建方法和使用的信息，LR分析器可以分为SLR分析器、Canonical LR分析器和LALR分析器。在实际应用中，LALR分析器在处理能力和实现复杂性之间取得了较好的平衡，因此被广泛使用。

# 语法制导翻译（语义分析和中间代码生成）

## SDD



## SDT
