# 一、
## 1、
- R 有 20000 个元组，一块可以容纳 20 个 R 元组，因此 R 需要 20000 / 20 = 1000 个磁盘块。
- S 有 60000 个元组，一块可以容纳 30 个 S 元组，因此 S 需要 60000 / 30 = 2000 个磁盘块。

对于嵌套循环连接来说，基本的 I/O 成本可以通过以下方式计算：

- 对于 R 中的每一个块，我们需要把它读入内存，这将消耗 R 的块数（1000）次 I/O。
- 对于 R 中的每一个块，我们需要扫描整个 S，这将消耗 R 的块数（1000）* S 的块数（2000）次 I/O。
因此，总的 I/O 成本就是 R 的块数 + R 的块数 * S 的块数 = 1000 + 1000 * 2000 = 2001000 次 I/O。

## 2. 
- R 有 20000 个元组，一块可以容纳 20 个 R 元组，因此 R 需要 20000 / 20 = 1000 个磁盘块。
- S 有 60000 个元组，一块可以容纳 30 个 S 元组，因此 S 需要 60000 / 30 = 2000 个磁盘块。

在归并连接中，需要对 R 和 S 做一次完整的扫描以进行比较和连接。所以总的 I/O 次数包括读取 R 和 S 的所有块
归并连接的 I/O 成本可以用以下公式计算：
I/O(R⨝S) = (I/O(R) + I/O(S))
总的 I/O 成本就是 (1000 + 2000) = 3000 次 I/O。

## 3、

- R 有 20000 个元组，一块可以容纳 20 个 R 元组。
- S 有 60000 个元组，一块可以容纳 30 个 S 元组。

在自然连接 R ⨝ S 中，每个 R 的元组将与 S 中匹配的元组连接起来。由于 R.B 是 R 的外键，参照 S.B，因此 R 和 S 在 B 上的值应该是一一对应的，也就是说，R ⨝ S 的结果应该有 20000 个元组（即 R 的元组数量）。

由于 R ⨝ S 的结果中元组的平均大小是 R 中元组平均大小的 1.2 倍，因此一个块可以容纳的 R ⨝ S 的元组数量应该是 R 的元组数量的 1 / 1.2 = 5 / 6。因此，一个块可以容纳 20 * (5 / 6) = 16.67 个 R ⨝ S 的元组。向上取整，我们认为一个块可以容纳 17 个 R ⨝ S 的元组。

那么，R ⨝ S 的结果应该需要 20000 / 17 = 1176.47 块。向上取整，我们需要 1177 块来存储 R ⨝ S 的结果。

# 二、

## 1、

- R 有 1000 个元组，每个块可以容纳 20 个 R 元组，因此 R 需要 1000 / 20 = 50 个块。
- S 有 1500 个元组，每个块可以容纳 30 个 S 元组，因此 S 需要 1500 / 30 = 50 个块。
- S 中 Y 不同值的个数为 20，平均每个 Y 值有 1500 / 20 = 75 个元组。

在索引连接中，对于 R 中的每个元组 r，我们都需要在 S 中查找与之匹配的元组 s。由于 S 中有聚簇索引，我们可以通过索引直接定位到所需的块，从而减少 I/O 的次数。

对于每个 r，我们需要做以下操作：

1. 通过索引查找对应的 s，假设索引查找需要一次 I/O。
2. 读取 S 中与 r 匹配的所有元组，平均需要 75 / 30 = 2.5 块，向上取整，我们认为需要 3 次 I/O。

所以，对于每个 r，我们总共需要 1 + 3 = 4 次 I/O。

因此，对于所有的 R，我们需要的 I/O 代价是 R 的元组数量 * 每个元组的 I/O 代价 = 1000 * 4 = 4000 次 I/O。

## 2.

- R 有 1000 个元组，每个块可以容纳 20 个 R 元组，因此 R 需要 1000 / 20 = 50 个块。
- S 有 1500 个元组，每个块可以容纳 30 个 S 元组，因此 S 需要 1500 / 30 = 50 个块。
- S 中 Y 不同值的个数为 20，平均每个 Y 值有 1500 / 20 = 75 个元组。

在非聚簇索引连接中，对于 R 中的每个元组 r，我们都需要在 S 中查找与之匹配的元组 s。由于 S 中有非聚簇索引，我们可以通过索引直接定位到所需的元组，但是因为非聚簇索引并不保证物理存储的顺序，可能需要更多的 I/O 次数。

对于每个 r，我们需要做以下操作：

1. 通过索引查找对应的 s，假设索引查找需要一次 I/O。
2. 读取 S 中与 r 匹配的所有元组。由于这是非聚簇索引，每个元组可能都在不同的块中，因此需要 75 次 I/O。

所以，对于每个 r，我们总共需要 1 + 75 = 76 次 I/O，但是由于75>50,所以可以直接将S中的元素加载进入，所以最多需要51次。

因此，对于所有的 R，我们需要的 I/O 代价是 R 的元组数量 * 每个元组的 I/O 代价 = 1000 * 51 = 51000 次 I/O。

# 三、

## 1.

$$
\pi_{sname}(\sigma_{Cname='数据库'(S\Join SC \Join C)})
$$

## 2.

对应的查询计划树为：

```
          π_SNAME
             |
         σ_CNAME="数据库"
             |
          ⨝_C.C#=SC.C#
         /          \
 ⨝_S.S#=SC.S#        C
 /         \
S           SC
```

然后，我们使用启发式查询优化算法对这个查询计划树进行优化。一般的启发式查询优化策略包括将选择操作和投影操作尽可能地推向查询树的叶节点，以及将小的关系放在连接操作的左边。

在这个查询计划树中，选择操作已经尽可能地接近叶节点。投影操作无法进一步向下推，因为它依赖于连接操作的结果。然而，我们可以优化连接操作的顺序。

假设 S, SC 和 C 的元组数量分别为 |S|, |SC| 和 |C|，我们不知道这些值，但是我们可以假设 |S| < |SC| < |C|，因为一位学生可以选择多门课程，一门课程可以被多位学生选择。所以，我们将连接操作的顺序改为先连接 S 和 SC，然后再连接结果和 C。

优化后的查询计划树为：

```
          π_SNAME
             |
          ⨝_C.C#=SC.C#
         /          \
    σ_CNAME="数据库"  C
         |
      ⨝_S.S#=SC.S#
     /         \
    S           SC
```

在这个优化后的查询计划树中，我们先执行 S 和 SC 的连接操作，然后执行选择操作，最后再执行与 C 的连接操作和投影操作。这样，我们可以尽早地过滤掉不满足条件的元组，减少后续操作的复杂性。

## 3.


对于优化前的查询计划：

1. `⨝_S.S#=SC.S#`：S 表与 SC 表自然连接，假设每一条 S 表的元组都能在 SC 表中找到匹配，那么中间结果的大小应该是 SC 表的大小，即 10000 条元组。
2. `⨝_C.C#=SC.C#`：上述连接结果与 C 表自然连接，由于 C 表的主键 C# 也是 SC 表的外键，同样假设每一条上述连接的结果都能在 C 表中找到匹配，那么中间结果的大小应该仍然是 10000 条元组。
3. `σ_CNAME="数据库"`：对上述连接结果进行选择操作，只保留 CNAME 为 "数据库" 的元组，根据题目给出的数据，这样的元组有 150 条。

对于优化后的查询计划：

1. `⨝_S.S#=SC.S#`：这一步与优化前的查询计划中的第一步相同，中间结果的大小应该是 10000 条元组。
2. `σ_CNAME="数据库"`：对 SC 表进行选择操作，只保留选修了 "数据库" 课程的元组，这样的元组有 150 条。
3. `⨝_C.C#=SC.C#`：上述选择结果与 C 表自然连接，每一条选择结果都能在 C 表中找到匹配（因为选择结果是根据 CNAME 从 SC 表中选择出来的），那么中间结果的大小应该是 150 条元组。

通过比较可以看出，优化后的查询计划在连接操作的中间结果大小上有显著的优势，能够更有效地减少计算和存储的开销。

# 四、
## 1、
```
                π_C.type
                   |
                σ_R.name='Tutu' ∧ C.weight>100 ∧ C.weight<500
                   |
                ⨝_R.rid=A.rid ∧ C.cid=A.cid
               /        |        \
             R         A         C

```
## 2、
```
            π_C.type
               |
            ⨝_C.cid=A.cid
           /          \
 σ_C.weight>100 ∧ C.weight<500 C     A
           |
       ⨝_R.rid=A.rid
      /         \
σ_R.name='Tutu'  R
```

# 五、

## 1、
```
         π_bname
            |
         σ_date='2021-06-04' ∧ dept='CS'
            |
     B ⨝_bno=bno ⨝_sno=sno S ⨝_sno=sno L

```

